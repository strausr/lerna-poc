import cloneDeep from 'lodash/cloneDeep';
import { PLACEHOLDER_IMAGE_OPTIONS, singleTransparentPixel } from '../utils/internalConstants';
import { isBrowser } from "../utils/isBrowser";
import { isImage } from "../utils/isImage";
/**
 * @namespace
 * @description Displays a placeholder image until the original image loads.
 * @param mode {PlaceholderMode} The type of placeholder image to display. Possible modes: 'vectorize' | 'pixelate' | 'blur' | 'predominant-color'. Default: 'vectorize'.
 * @return {Plugin}
 * @example
 * <AdvancedImage cldImg={img} plugins=[(placeholder('blur'))]/>
 */
export function placeholder(mode) {
    if (mode === void 0) { mode = 'vectorize'; }
    return placeholderPlugin.bind(null, mode);
}
/**
 * @description Placeholder plugin
 * @param mode {placeholderMode} The type of placeholder image to display. Possible modes: 'vectorize' | 'pixelate' | 'blur' | 'predominant-color'. Default: 'vectorize'.
 * @param element {HTMLImageElement} The image element.
 * @param pluginCloudinaryImage {CloudinaryImage}
 * @param htmlPluginState {htmlPluginState} Holds cleanup callbacks and event subscriptions.
 */
function placeholderPlugin(mode, element, pluginCloudinaryImage, htmlPluginState) {
    if (!isBrowser())
        return;
    if (!isImage(element))
        return;
    var placeholderTransformation = preparePlaceholderTransformation(mode, pluginCloudinaryImage);
    element.src = placeholderTransformation.toURL();
    //if placeholder does not load, load a single transparent pixel
    element.onerror = function () {
        element.src = singleTransparentPixel;
    };
    /*
    Placeholder image loads first. Once it loads, the promise is resolved and the
    larger image will load. Once the larger image loads, promised and plugin is resolved.
     */
    return new Promise(function (resolve) {
        element.onload = function () {
            resolve();
        };
    }).then(function () {
        return new Promise(function (resolve) {
            htmlPluginState.cleanupCallbacks.push(function () {
                element.src = singleTransparentPixel;
                resolve('canceled');
            });
            // load image once placeholder is done loading
            var largeImage = new Image();
            largeImage.src = pluginCloudinaryImage.toURL();
            largeImage.onload = function () {
                resolve();
            };
            // image does not load, resolve
            largeImage.onerror = function () {
                resolve();
            };
        });
    });
}
/**
 * Prepares placeholder transformation by appending a placeholder-type transformation to the end of the URL
 * @param mode {PlaceholderMode} The type of placeholder image to display. Possible modes: 'vectorize' | 'pixelate' | 'blur' | 'predominant-color'. Default: 'vectorize'.
 * @param pluginCloudinaryImage {CloudinaryImage}
 */
function preparePlaceholderTransformation(mode, pluginCloudinaryImage) {
    var placeholderClonedImage = cloneDeep(pluginCloudinaryImage);
    // @ts-ignore
    if (!PLACEHOLDER_IMAGE_OPTIONS[mode]) {
        mode = 'vectorize';
    }
    //appends a placeholder transformation on placeholderClonedImage
    // @ts-ignore
    PLACEHOLDER_IMAGE_OPTIONS[mode].actions.forEach(function (transformation) {
        placeholderClonedImage.addAction(transformation);
    });
    return placeholderClonedImage;
}
