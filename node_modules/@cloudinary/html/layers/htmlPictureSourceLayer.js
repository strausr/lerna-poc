import { screeWidths } from "../utils/screenWidths";
// @ts-ignore
import cloneDeep from "lodash/cloneDeep";
import { scale } from "@cloudinary/url-gen/actions/resize";
var DEFAULT_MAX_WIDTH = 3840;
var DEFAULT_MIN_WIDTH = 375;
// constant used to generate the number of default breakpoints
var MAX_IMAGES = 5;
// constant used to estimate and simulate dpr
var DEFAULT_DPR_THRESHOLD = 768;
var HtmlPictureSourceLayer = /** @class */ (function () {
    function HtmlPictureSourceLayer(image, minWidth, maxWidth, sizes, autoOptimalBreakpoints, breakpoints, relativeWidth) {
        if (relativeWidth === void 0) { relativeWidth = 1; }
        this.image = image;
        this.minWidth = minWidth;
        this.maxWidth = maxWidth;
        this.sizes = sizes;
        this.relativeWidth = relativeWidth;
        this.autoOptimalBreakpoints = autoOptimalBreakpoints;
        this.breakpoints = breakpoints;
    }
    HtmlPictureSourceLayer.prototype.toTag = function () {
        var source = document.createElement('source');
        this.setMedia(source);
        this.setSize(source);
        this.generateSrcsetUrl(source);
        return source;
    };
    /**
     * @description Sets Source element's media attribute
     * @param source {HTMLSourceElement} Source element
     */
    HtmlPictureSourceLayer.prototype.setMedia = function (source) {
        if (this.maxWidth && this.minWidth) {
            source.media = "(min-width: " + this.minWidth + "px) and (max-width: " + this.maxWidth + "px)";
        }
        else if (this.maxWidth) {
            source.media = "(max-width: " + this.maxWidth + "px)";
        }
        else if (this.minWidth) {
            source.media = "(min-width: " + this.minWidth + "px)";
        }
    };
    /**
     * @description Sets Source element's size attribute
     * @param source {HTMLSourceElement} Source element
     */
    HtmlPictureSourceLayer.prototype.setSize = function (source) {
        if (this.sizes && this.autoOptimalBreakpoints) {
            console.error("Invalid input: sizes must not be used with autoOptimalBreakpoints");
        }
        if (this.sizes) {
            source.sizes = this.sizes;
        }
        else if (this.relativeWidth && this.autoOptimalBreakpoints) {
            source.sizes = Math.ceil(this.relativeWidth * 100) + "vw";
        }
    };
    /**
     * @description Generates Source element srcset attribute
     * @param source {HTMLSourceElement} Source element
     */
    HtmlPictureSourceLayer.prototype.generateSrcsetUrl = function (source) {
        var _this = this;
        var breakpoints = this.getBreakPoints();
        if (breakpoints.length === 0) {
            source.srcset = this.image.toURL();
            return;
        }
        var breakpointUrls = [];
        breakpoints.forEach(function (breakPoint) {
            var width = Math.ceil(breakPoint * _this.relativeWidth);
            var clone = cloneDeep(_this.image);
            breakpointUrls.push(clone.resize(scale(width)).toURL() + " " + width + "w");
        });
        source.srcset = breakpointUrls.join(',');
    };
    /**
      * @description An array of breakpoints is calculated and returned based on the
      * predefined constants in screenWidths
      * See conditions bellow
      */
    HtmlPictureSourceLayer.prototype.getBreakPoints = function () {
        if (this.breakpoints) {
            return this.breakpoints;
        }
        if (!this.autoOptimalBreakpoints) {
            return [];
        }
        if (!this.minWidth && !this.maxWidth) {
            console.error("Invalid input: either maxWidth or minWidth is required");
        }
        if (this.minWidth > this.maxWidth) {
            console.error("Invalid input: maxWidth must be greater than minWidth");
        }
        var _a = this.getPhysicalDimension(), physicalMinWidth = _a[0], physicalMaxWidth = _a[1];
        if (physicalMinWidth === physicalMaxWidth) {
            return [physicalMaxWidth];
        }
        //Take 5 (or up to 5) sorted widths with highest rank between physicalMaxWidth and physicalMinWidth
        return screeWidths.filter(function (width) {
            return width <= physicalMaxWidth && width >= physicalMinWidth;
        }).slice(0, MAX_IMAGES)
            .sort(function (a, b) { return a - b; });
    };
    /**
     * @description Returns the physical dimensions
     */
    HtmlPictureSourceLayer.prototype.getPhysicalDimension = function () {
        var _a;
        var maxWidth = this.maxWidth || DEFAULT_MAX_WIDTH;
        var minWidth = this.minWidth || DEFAULT_MIN_WIDTH;
        var physicalMaxWidth = this.getDprDimension(maxWidth);
        var physicalMinWidth = this.getDprDimension(minWidth);
        // if physicalMinWidth is greater we swap
        if (physicalMinWidth > physicalMaxWidth) {
            _a = [physicalMaxWidth, physicalMinWidth], physicalMinWidth = _a[0], physicalMaxWidth = _a[1];
        }
        return [physicalMinWidth, physicalMaxWidth];
    };
    /**
     * @description If dimension is less than default DPR threshold we multiply by 2
     * @param dimension {number} Estimates DPR bases on max and min width
     */
    HtmlPictureSourceLayer.prototype.getDprDimension = function (dimension) {
        return dimension < DEFAULT_DPR_THRESHOLD ? dimension * 2 : dimension;
    };
    return HtmlPictureSourceLayer;
}());
export { HtmlPictureSourceLayer };
