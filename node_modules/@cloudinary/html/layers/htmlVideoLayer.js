import cloneDeep from 'lodash/cloneDeep';
import { render } from '../utils/render';
import { VIDEO_MIME_TYPES } from "../utils/internalConstants";
var HtmlVideoLayer = /** @class */ (function () {
    function HtmlVideoLayer(element, userCloudinaryVideo, sources, plugins, videoAttributes) {
        var _this = this;
        this.mimeType = 'video';
        this.mimeSubTypes = VIDEO_MIME_TYPES;
        this.videoElement = element;
        this.originalVideo = userCloudinaryVideo;
        this.htmlPluginState = { cleanupCallbacks: [], pluginEventSubscription: [] };
        var pluginCloudinaryVideo = cloneDeep(userCloudinaryVideo);
        render(element, userCloudinaryVideo, plugins, this.htmlPluginState)
            .then(function () {
            _this.htmlPluginState.pluginEventSubscription.forEach(function (fn) { fn(); });
            _this.setVideoAttributes(videoAttributes);
            _this.handleSourceToVideo(pluginCloudinaryVideo, sources);
        });
    }
    /**
     * Handles user supplied sources or default sources
     * @param userCloudinaryVideo {CloudinaryVideo}
     * @param sources
     */
    HtmlVideoLayer.prototype.handleSourceToVideo = function (userCloudinaryVideo, sources) {
        var _this = this;
        // checks if user supplied sources
        if (sources) {
            this.generateUserSources(userCloudinaryVideo, sources);
        }
        else {
            var defaultTypes = ['webm', 'mp4', 'ogg'];
            defaultTypes.forEach(function (type) {
                _this.appendSourceTag(userCloudinaryVideo, type);
            });
        }
    };
    /**
     * Generate sources based on user input
     * @param userCloudinaryVideo {CloudinaryVideo}
     * @param sources
     */
    HtmlVideoLayer.prototype.generateUserSources = function (userCloudinaryVideo, sources) {
        var _this = this;
        sources.map(function (_a) {
            var type = _a.type, codecs = _a.codecs, transcode = _a.transcode;
            return (_this.appendSourceTag(cloneDeep(userCloudinaryVideo)
                .transcode(transcode), type, _this.buildMimeType(type, codecs)));
        });
    };
    /**
     * Appends source tag to html video element
     * @param userCloudinaryVideo {CloudinaryVideo}
     * @param type {string}
     * @param mimeType {string}
     */
    HtmlVideoLayer.prototype.appendSourceTag = function (userCloudinaryVideo, type, mimeType) {
        var source = document.createElement('source');
        source.src = userCloudinaryVideo.toURL() + "." + type;
        source.type = mimeType ? mimeType : "video/" + type;
        this.videoElement.appendChild(source);
    };
    /**
     * Determines MIME type of given source type and codecs.
     * @param type - format of the video
     * @param codecs - optional information about codecs of the video
     */
    HtmlVideoLayer.prototype.buildMimeType = function (type, codecs) {
        var mimeType = this.mimeType + "/" + (this.mimeSubTypes[type] || type);
        if (codecs) {
            mimeType += "; codecs=" + (Array.isArray(codecs) ? codecs.join(', ') : codecs);
        }
        return mimeType;
    };
    ;
    /**
     * Iterates through the video attributes and sets to true if passed in by the user.
     * In case of poster, sets the poster.
     * @param videoAttributes {object} Supported attributes: controls, loop, muted, poster, preload, autoplay, playsinline
     */
    HtmlVideoLayer.prototype.setVideoAttributes = function (videoAttributes) {
        if (!videoAttributes)
            return;
        for (var _i = 0, _a = Object.entries(videoAttributes); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (value) {
                if (key === 'poster') {
                    this.videoElement.poster = value;
                }
                else {
                    this.videoElement[key] = true;
                }
            }
        }
    };
    /**
     * Called when component is updated. If our video source has changed, a video reload is triggered.
     * @param updatedCloudinaryVideo
     * @param sources
     * @param plugins
     * @param videoAttributes
     */
    HtmlVideoLayer.prototype.update = function (updatedCloudinaryVideo, sources, plugins, videoAttributes) {
        var _this = this;
        if (updatedCloudinaryVideo !== this.originalVideo) {
            var sourcesToDelete = this.videoElement.getElementsByTagName("SOURCE");
            while (sourcesToDelete[0])
                sourcesToDelete[0].parentNode.removeChild(sourcesToDelete[0]);
            render(this.videoElement, updatedCloudinaryVideo, plugins, this.htmlPluginState)
                .then(function () {
                _this.setVideoAttributes(videoAttributes);
                _this.handleSourceToVideo(updatedCloudinaryVideo, sources);
                _this.videoElement.load();
            });
        }
    };
    return HtmlVideoLayer;
}());
export { HtmlVideoLayer };
